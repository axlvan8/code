//core.min.js github.com/axlvan8/code axlvan8.github.io/code/core.min.js
export function getCTX(canvasId){
    const canvas=document.getElementById(canvasId);const ctx=canvas.getContext('2d');return ctx;
}
export async function repeatUntil(conditionFn, actionFn, intervalMs = 100){
  return new Promise(resolve => {
    const interval = setInterval(async () => {
      await actionFn();
      if (conditionFn()) {
        clearInterval(interval);
        resolve();
      }
    }, intervalMs);
  });
}
export function waitUntil(conditionFn) {
  return new Promise(resolve => {
    const interval = setInterval(() => {
      if (conditionFn()) {
        clearInterval(interval);
        resolve();
      }
    }, 50);
  });
  

}

export function createtextfile(text){
    if(!text){return}const blob = new Blob([text], { type: "text/plain" });
}
export function sqcollide(x1,y1,x2,y2,x3,y3,x4,y4){
    var collide=((Math.abs(x1-x3)<((x2/2)+(x4/2)))&&((Math.abs(y1-y3))<(y2/2)+(y4/2)));return collide
}
export function maketab(title,text){
    var tab = window.open();
    tab.document.open();
    tab.document.write(text);
    tab.document.title=title;
    tab.document.close();
}
export function differscroll(x1,x2,scroll){
    var differ=((((((x1-x2)+(scroll/2))%scroll)+scroll)%scroll)-(scroll/2));return differ;
}
export const humanoid = {
    head: {x:0, y:1.8, z:0, r:0.25},
    torso: {x:0, y:1.0, z:0, w:0.5, h:0.8, d:0.3},
    leftArm: {x:-0.4, y:1.4, z:0, length:0.7, radius:0.1, rot:0},
    rightArm: {x:0.4, y:1.4, z:0, length:0.7, radius:0.1, rot:0},
    leftLeg: {x:-0.2, y:0.4, z:0, length:0.8, radius:0.1, rot:0},
    rightLeg: {x:0.2, y:0.4, z:0, length:0.8, radius:0.1, rot:0}
};
export function copyToClipboard(elementId) {
    const el = document.getElementById(elementId);
    if (!el) return;

    const text = el.textContent || el.value;
    if (!text) {
        alert("Nothing to copy.");
        return;
    }

    navigator.clipboard.writeText(text)
        .then(() => {
            
        })
        .catch((err) => {
            console.error("Clipboard error:", err);
            alert("Failed to copy.");
        });
}
function drawCylinder(x1,y1,z1,x2,y2,z2,r,color,steps=6){
    
    for(let i=0;i<=steps;i++){
        const t = i/steps;
        drawSphere(
            x1 + (x2-x1)*t,
            y1 + (y2-y1)*t,
            z1 + (z2-z1)*t,
            r,
            color
        );
    }
}
export function drawHumanoid(baseX, baseY, baseZ, rotY, color="skin") {
    const skin = color==="skin" ? "#e0a082" : color;

    // Head
    drawSphere(baseX, baseY + humanoid.head.y, baseZ, humanoid.head.r, skin);

    // Torso
    drawCylinder(
        baseX, baseY + humanoid.torso.y - humanoid.torso.h/2, baseZ,
        baseX, baseY + humanoid.torso.y + humanoid.torso.h/2, baseZ,
        0.25, "#444"
    );

    // Arms
    const leftArmTop = {x: baseX - 0.4, y: baseY + humanoid.leftArm.y, z: baseZ};
    drawCylinder(
        leftArmTop.x, leftArmTop.y, leftArmTop.z,
        leftArmTop.x, leftArmTop.y - humanoid.leftArm.length, leftArmTop.z,
        humanoid.leftArm.radius, skin
    );

    const rightArmTop = {x: baseX + 0.4, y: baseY + humanoid.rightArm.y, z: baseZ};
    drawCylinder(
        rightArmTop.x, rightArmTop.y, rightArmTop.z,
        rightArmTop.x, rightArmTop.y - humanoid.rightArm.length, rightArmTop.z,
        humanoid.rightArm.radius, skin
    );

    // Weapon in right hand
    const handY = rightArmTop.y - humanoid.rightArm.length;
    drawWeapon(rightArmTop.x, handY, rightArmTop.z, rotY);

    // Legs
    drawCylinder(
        baseX - 0.2, baseY + humanoid.leftLeg.y, baseZ,
        baseX - 0.2, baseY + humanoid.leftLeg.y - humanoid.leftLeg.length, baseZ,
        humanoid.leftLeg.radius, skin
    );

    drawCylinder(
        baseX + 0.2, baseY + humanoid.rightLeg.y, baseZ,
        baseX + 0.2, baseY + humanoid.rightLeg.y - humanoid.rightLeg.length, baseZ,
        humanoid.rightLeg.radius, skin
    );
}
export function drawSphere(x,y,z,r,color,ctx) {
   
    const p = project3D(x,y,z);
    if (!p) return;

    const size = 200 / p.d;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, size*r, 0, Math.PI*2);
    ctx.fill();
}
export function project3D(x, y, z) {
    var dx = x - cam.x;
    var dy = y - cam.y;
    var dz = z - cam.z;

    // Y rotation (turn left/right)
    const sy = Math.sin(cam.rotY), cy = Math.cos(cam.rotY);
    var rx = dx * cy - dz * sy;
    var rz = dx * sy + dz * cy;

    // X rotation (look up/down)
    const sx = Math.sin(cam.rotX), cx = Math.cos(cam.rotX);
    var ry = dy * cx - rz * sx;
    rz = dy * sx + rz * cx;

    if (rz < 0.1) return null;

    const scale = 400 / rz;

    return {
        x: 450 + rx * scale,
        y: 300 - ry * scale,
        d: rz
    };
}
export var cam = {
    x:0, y:1.7, z:0,
    rotY:0,
    rotX:0
};






