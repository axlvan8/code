<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Cube Game</title>
  <style>
    body {
  margin: 0;
  overflow: hidden;
  background: linear-gradient(to bottom, #001d3d, white);

}

    canvas {
      display: block;
      margin: 0 auto;
      background: white;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="900" height="900"></canvas>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const camera = {
      position: [0, 0, -5],
      rotation: [0, 0] // pitch (x), yaw (y)
    };

    const cubePoints = [
      [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
      [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
    ];

    const edges = [
      [0, 1], [1, 2], [2, 3], [3, 0],
      [4, 5], [5, 6], [6, 7], [7, 4],
      [0, 4], [1, 5], [2, 6], [3, 7]
    ];

    const player = { size: 0.6 };
    let obstacles = [];
    let score = 0;
    let gameOver = false;
    const keys = {};

    // Handle key input
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    // Mouse look
    function onMouseMove(e) {
      const sensitivity = 0.002;
      camera.rotation[1] -= e.movementX * sensitivity; // yaw
      camera.rotation[0] -= e.movementY * sensitivity; // pitch

      // Clamp pitch
      const maxPitch = Math.PI / 2 - 0.01;
      camera.rotation[0] = Math.max(-maxPitch, Math.min(maxPitch, camera.rotation[0]));
    }

    // Pointer lock for mouse look
    canvas.addEventListener("click", () => canvas.requestPointerLock());
    document.addEventListener("pointerlockchange", () => {
      if (document.pointerLockElement === canvas) {
        document.addEventListener("mousemove", onMouseMove);
      } else {
        document.removeEventListener("mousemove", onMouseMove);
      }
    });

    // Rotate and project
    function project([x, y, z]) {
      // Translate relative to camera
      x -= camera.position[0];
      y -= camera.position[1];
      z -= camera.position[2];

      // Camera rotation (yaw then pitch)
      const cosY = Math.cos(-camera.rotation[1]);
      const sinY = Math.sin(-camera.rotation[1]);
      let dx = x * cosY - z * sinY;
      let dz = x * sinY + z * cosY;

      const cosX = Math.cos(-camera.rotation[0]);
      const sinX = Math.sin(-camera.rotation[0]);
      let dy = y * cosX - dz * sinX;
      dz = y * sinX + dz * cosX;

      const scale = 500 / (dz + 5);
      return [dx * scale + width / 2, dy * scale + height / 2];
    }

    function drawCube(pos, scale = 1, baseColor = "lime") {
  // Calculate approximate depth (distance from camera)
  const dx = pos[0] - camera.position[0];
  const dy = pos[1] - camera.position[1];
  const dz = pos[2] - camera.position[2];
  const depth = Math.sqrt(dx * dx + dy * dy + dz * dz);

  // Apply fog
  const color = applyFogColor(baseColor, depth);

  ctx.strokeStyle = color;
  ctx.lineWidth = 2;

  const points = cubePoints.map(([px, py, pz]) =>
    project([px * scale + pos[0], py * scale + pos[1], pz * scale + pos[2]])
  );

  for (const [a, b] of edges) {
    const [x1, y1] = points[a];
    const [x2, y2] = points[b];
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
}


    function drawGrid() {
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1;

      for (let i = -100; i <= 100; i++) {
        const p1 = project([i, -100, 0]);
        const p2 = project([i, 100, 0]);
        ctx.beginPath();
        ctx.moveTo(...p1);
        ctx.lineTo(...p2);
        ctx.stroke();

        const p3 = project([-100, i, 0]);
        const p4 = project([100, i, 0]);
        ctx.beginPath();
        ctx.moveTo(...p3);
        ctx.lineTo(...p4);
        ctx.stroke();
      }
    }

   function drawPlayerIndicator() {
  // Position slightly in front of camera (reticle/body)
  const camDir = [
    Math.sin(camera.rotation[1]),
    0,
    Math.cos(camera.rotation[1])
  ];
  const playerPos = [
    camera.position[0] + camDir[0] * 1,
    camera.position[1],
    camera.position[2] + camDir[2] * 1
  ];
  drawCube(playerPos, 0.3, "cyan");
}


    function spawnObstacle() {
      const x = (Math.random() - 0.5) * 10;
      const y = (Math.random() - 0.5) * 10;
      obstacles.push({
  position: [x, y, camera.position[2] + 15],
  speed: 0.05,
  color: `hsl(${Math.random() * 360}, 100%, 50%)`
});

    }

    function updateCameraMovement() {
      const speed = 0.1;
      const yaw = camera.rotation[1];

      if (keys["w"]) {
        camera.position[0] += Math.sin(yaw) * speed;
        camera.position[2] += Math.cos(yaw) * speed;
      }
      if (keys["s"]) {
        camera.position[0] -= Math.sin(yaw) * speed;
        camera.position[2] -= Math.cos(yaw) * speed;
      }
      if (keys["a"]) {
        camera.position[0] -= Math.cos(yaw) * speed;
        camera.position[2] += Math.sin(yaw) * speed;
      }
      if (keys["d"]) {
        camera.position[0] += Math.cos(yaw) * speed;
        camera.position[2] -= Math.sin(yaw) * speed;
      }
      if (keys["q"] || keys["arrowup"]) camera.position[1] -= speed;
      if (keys["e"] || keys["arrowdown"]) camera.position[1] += speed;
    }
function draw() {
  if (gameOver) return;

  ctx.clearRect(0, 0, width, height);
  updateCameraMovement();
  drawGrid();
  drawPlayerIndicator();
  drawCrosshair();

  // Update and draw obstacles
  for (let i = 0; i < obstacles.length; i++) {
    const ob = obstacles[i];
    ob.position[2] -= ob.speed;
    drawCube(ob.position, 0.3, ob.color);


    // Collision with player
    if (Math.abs(ob.position[0] - camera.position[0]) < player.size &&
        Math.abs(ob.position[1] - camera.position[1]) < player.size &&
        Math.abs(ob.position[2] - camera.position[2]) < player.size) {
      gameOver = true;
      alert("ðŸ’¥ Game Over! Score: " + score);
      return;
    }
  }

  // Remove obstacles behind player
  obstacles = obstacles.filter(ob => ob.position[2] > camera.position[2] - 2);

  // Update enemies and projectiles once per frame
  updateEnemies();
  updateProjectiles();

  score++;
  ctx.fillStyle = "white";
  ctx.font = "20px monospace";
  ctx.fillText("Score: " + score, 20, 30);

  requestAnimationFrame(draw);
}

    function drawCrosshair() {
  const centerX = width / 2;
  const centerY = height / 2;
ctx.strokeStyle = `hsl(${(Date.now()/10)%360}, 100%, 70%)`;

  ctx.beginPath();
  ctx.moveTo(centerX - 5, centerY);
  ctx.lineTo(centerX + 5, centerY);
  ctx.moveTo(centerX, centerY - 5);
  ctx.lineTo(centerX, centerY + 5);
  ctx.stroke();
}

    setInterval(() => {
      if (!gameOver) spawnObstacle();
    }, 1000);
    let projectiles = [];
let enemies = [];

canvas.addEventListener("click", () => {
  const yaw = camera.rotation[1];
  const pitch = camera.rotation[0];

  const dx = Math.sin(yaw) * Math.cos(pitch);
  const dy = Math.sin(pitch);
  const dz = Math.cos(yaw) * Math.cos(pitch); // âœ… removed the negative

  const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
  const dir = [dx / length, dy / length, dz / length];

  // Start position: slightly further to prevent clipping
  const offset = 1.5;
  const startPos = [
    camera.position[0] + dir[0] * offset,
    camera.position[1] + dir[1] * offset,
    camera.position[2] + dir[2] * offset
  ];

  projectiles.push({
    position: startPos,
    direction: dir,
    speed: 0.3
  });
});



// Enemy spawn (similar to obstacles but smarter)
function spawnEnemy() {
  const x = (Math.random() - 0.5) * 10;
  const y = (Math.random() - 0.5) * 10;
  enemies.push({
    position: [x, y, camera.position[2] + 20],
    speed: 0.02
  });
}

setInterval(() => {
  if (!gameOver) spawnEnemy();
}, 3000);

function updateEnemies() {
  for (const enemy of enemies) {
    
    let dx = camera.position[0] - enemy.position[0];
    let dy = camera.position[1] - enemy.position[1];
    let dz = camera.position[2] - enemy.position[2];

    
    const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if (length > 0) {
      dx /= length;
      dy /= length;
      dz /= length;
    }

    
    enemy.position[0] += dx * enemy.speed;
    enemy.position[1] += dy * enemy.speed;
    enemy.position[2] += dz * enemy.speed;

  
    const hue = ((enemy.position[0] + enemy.position[2]) * 20) % 360;
drawCube(enemy.position, 0.4, `hsl(${hue}, 100%, 50%)`);


  
    if (Math.abs(camera.position[0] - enemy.position[0]) < player.size &&
    Math.abs(camera.position[1] - enemy.position[1]) < player.size &&
    Math.abs(camera.position[2] - enemy.position[2]) < player.size){

      gameOver = true;
      alert("Game Over! You were caught by an enemy! Score: " + score);
      return;
    }
  }
}

function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    let p = projectiles[i];
    p.position[0] += p.direction[0] * p.speed;
    p.position[1] += p.direction[1] * p.speed;
    p.position[2] += p.direction[2] * p.speed;

    // Draw projectile as small cube or dot
    const hue = (Date.now() / 5) % 360;
drawCube(p.position, 0.1, `hsl(${hue}, 100%, 60%)`);


    // Remove if too far
    if (p.position[2] > camera.position[2] + 30) {
      projectiles.splice(i, 1);
      continue;
    }

    // Check collision with enemies
    for (let j = enemies.length - 1; j >= 0; j--) {
      let e = enemies[j];
      if (Math.abs(p.position[0] - e.position[0]) < 0.5 &&
          Math.abs(p.position[1] - e.position[1]) < 0.5 &&
          Math.abs(p.position[2] - e.position[2]) < 0.5) {
        enemies.splice(j, 1);
        projectiles.splice(i, 1);
        score += 50; // Bonus for killing enemy
        break;
      }
    }
  }
}
function applyFogColor(baseColor, depth, maxDepth = 30, fogColor = [0, 0, 0]) {
  const fogFactor = Math.min(1, depth / maxDepth);

  const temp = document.createElement("div");
  temp.style.color = baseColor;
  document.body.appendChild(temp);
  const rgb = getComputedStyle(temp).color.match(/\d+/g).map(Number);
  document.body.removeChild(temp);

  const r = Math.round(rgb[0] * (1 - fogFactor) + fogColor[0] * fogFactor);
  const g = Math.round(rgb[1] * (1 - fogFactor) + fogColor[1] * fogFactor);
  const b = Math.round(rgb[2] * (1 - fogFactor) + fogColor[2] * fogFactor);

  return `rgb(${r},${g},${b})`;
}


    draw();
  </script>
</body>
</html>
