<!DOCTYPE html>
<html>
    <head>
        <title>no name</title>
        <meta charset="UTF-8">
        <style>
            #a{
                background-color: grey;
                display: none;
            }
            #wall{
                display: none;
            }
        </style>
    </head>
    <body>
        <p id="h">Choose a side:</p>
        <button onclick="d('white')" id="f">white</button>
        <button onclick="d('black')" id="g">black</button>
        <svg height="800" width="800" id="a">
            <circle cx="750" cy="750" id="b" r="20" fill="white"></circle>
            <circle cx="50" cy="50" id="c" r="20" fill="black"></circle>
            <rect id="wall1" x="200" y="200" width="100" height="20" fill="brown" />
            <rect id="wall2" x="400" y="300" width="20" height="100" fill="brown" />
            <rect id="cooldownBar" x="0" y="0" width="0" height="5" fill="lime" visibility="hidden" />


        </svg>
        <div id="hpDisplay" style="margin-top: 10px; font-size: 18px;">
            <span id="playerHP">Your HP: 3</span> |
            <span id="opponentHP">Opponent HP: 3</span>
        </div>

        <p id="w"></p>
        <button id="wall" onclick="buildWall()"><img src="Drawing-6.sketchpad.jpeg" height="100" width="100"></button>
        <script>
            let opponentAlive = true;
let playerAlive = true;

let opponentCanDodge = true;
const dodgeCooldown = 2000;
const dodgeChance = 0.3;

            let t = true;
            let opponentCanShoot = true;
        

            

            function updateHPDisplay() {
                document.getElementById("playerHP").textContent = `Your HP: ${playerHP}`;
                document.getElementById("opponentHP").textContent = `Opponent HP: ${opponentHP}`;
            }

            let playerHP = 3;
            let opponentHP = 3;

            let canShoot = true;
            const shootCooldown = 500;

            let facing = "d";

            const game = document.getElementById("a");
            const b = document.getElementById("b");
            const c = document.getElementById("c");
            var a;
            function hasLineOfSight(x1, y1, x2, y2) {
    const walls = document.querySelectorAll("rect");
    const samples = 20;

    for (let i = 0; i <= samples; i++) {
        const t = i / samples;
        const x = x1 + (x2 - x1) * t;
        const y = y1 + (y2 - y1) * t;

        for (const wall of walls) {
            if (!wall.id.startsWith("wall")) continue;

            const wx = parseFloat(wall.getAttribute("x"));
            const wy = parseFloat(wall.getAttribute("y"));
            const ww = parseFloat(wall.getAttribute("width"));
            const wh = parseFloat(wall.getAttribute("height"));

            if (x >= wx && x <= wx + ww && y >= wy && y <= wy + wh) {
                return false; // LOS blocked
            }
        }
    }

    return true; // LOS clear
}

            function d(e){
                a = e;
                game.style.display = "block";
                document.getElementById("f").style.display = "none"
                document.getElementById("g").style.display = "none"
                document.getElementById("h").style.display = "none"
                document.getElementById("wall").style.display = "block"
                alert("Use w a s d to move, arrows to throw, and click the wall button to build")
                startOpponentAI();
            }
            
        document.addEventListener("keydown", function (event) {
    if (!a || !playerAlive) return;

    const player = a === "white" ? b : c;
    const opponent = a === "white" ? c : b;

    let cx = parseInt(player.getAttribute("cx"));
    let cy = parseInt(player.getAttribute("cy"));

    const opponentCx = parseInt(opponent.getAttribute("cx"));
    const opponentCy = parseInt(opponent.getAttribute("cy"));

    const step = 10;
    const radius = parseInt(player.getAttribute("r"));
    const opponentRadius = parseInt(opponent.getAttribute("r"));

    let newCx = cx;
    let newCy = cy;

    switch (event.key) {
        case "w":
            newCy -= step;
            facing = "w";
            break;
        case "a":
            newCx -= step;
            facing = "a";
            break;
        case "s":
            newCy += step;
            facing = "s";
            break;
        case "d":
            newCx += step;
            facing = "d";
            break;

        
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
            shootProjectile(event.key);
            return;

        default:
            return;
    }


    const dx = newCx - opponentCx;
    const dy = newCy - opponentCy;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < radius + opponentRadius) {
        console.log("Blocked: player would collide with opponent");
        return;
    }

    
    if (i(newCx, newCy, radius)) {
        console.log("Blocked: wall collision");
        return;
    }

    
    player.setAttribute("cx", newCx);
    player.setAttribute("cy", newCy);
});

function i(newCx, newCy, radius) {
    const walls = document.querySelectorAll("rect");

    for (const wall of walls) {
        if (wall.id.startsWith("wall")) {
            const wx = parseFloat(wall.getAttribute("x"));
            const wy = parseFloat(wall.getAttribute("y"));
            const ww = parseFloat(wall.getAttribute("width"));
            const wh = parseFloat(wall.getAttribute("height"));

            const closestX = Math.max(wx, Math.min(newCx, wx + ww));
            const closestY = Math.max(wy, Math.min(newCy, wy + wh));

            const dx = newCx - closestX;
            const dy = newCy - closestY;

            if ((dx * dx + dy * dy) < (radius * radius)) {
                return true;
            }
        }
    }
    return false;
}
          function buildWall() {
    if (!a) return;

    const svg = document.getElementById("a");
    const player = a === "white" ? b : c;

    const cx = parseInt(player.getAttribute("cx"));
    const cy = parseInt(player.getAttribute("cy"));
    const radius = parseInt(player.getAttribute("r"));

    let wallX = cx;
    let wallY = cy;
    const wallWidth = 40;
    const wallHeight = 10;

    switch (facing) {
        case "w":
            wallX = cx - wallWidth / 2;
            wallY = cy - radius - wallHeight - 2;
            break;
        case "s":
            wallX = cx - wallWidth / 2;
            wallY = cy + radius + 2;
            break;
        case "a":
            wallX = cx - radius - wallHeight - 2;
            wallY = cy - wallWidth / 2;
            break;
        case "d":
            wallX = cx + radius + 2;
            wallY = cy - wallWidth / 2;
            break;
    }

    const wall = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    wall.setAttribute("id", "wall" + Date.now()); // or a unique id
    wall.setAttribute("x", wallX);
    wall.setAttribute("y", wallY);
    if (facing === "w" || facing === "s") {
        wall.setAttribute("width", wallWidth);
        wall.setAttribute("height", wallHeight);
    } else {
        wall.setAttribute("width", wallHeight);
        wall.setAttribute("height", wallWidth);
    }
    wall.setAttribute("fill", "brown");
    svg.appendChild(wall);
}
  function shootProjectile(direction) {
    if (!canShoot) return;
    canShoot = false;

    setTimeout(() => { canShoot = true; }, shootCooldown);

    const svg = document.getElementById("a");
    const player = a === "white" ? b : c;
    const cx = parseInt(player.getAttribute("cx"));
    const cy = parseInt(player.getAttribute("cy"));

    const projectile = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    projectile.setAttribute("cx", cx);
    projectile.setAttribute("cy", cy);
    projectile.setAttribute("r", 5);
    projectile.setAttribute("fill", "red");
    svg.appendChild(projectile);

    const speed = 5;
    let dx = 0, dy = 0;
    switch (direction) {
        case "ArrowUp": dy = -speed; break;
        case "ArrowDown": dy = speed; break;
        case "ArrowLeft": dx = -speed; break;
        case "ArrowRight": dx = speed; break;
        default: return;
    }

    const magnitude = Math.sqrt(dx * dx + dy * dy);
    const vx = (dx / magnitude) * speed;
    const vy = (dy / magnitude) * speed;

    function move() {
        let x = parseFloat(projectile.getAttribute("cx"));
        let y = parseFloat(projectile.getAttribute("cy"));

        x += vx;
        y += vy;

        // Check collision with walls
        if (checkProjectileWallCollision(x, y, 5)) {
            svg.removeChild(projectile);
            return;
        }

        // Update position
        projectile.setAttribute("cx", x);
        projectile.setAttribute("cy", y);

        // Out of bounds
        if (x < 0 || x > 800 || y < 0 || y > 800) {
            svg.removeChild(projectile);
            return;
        }

        // Check if hit opponent
        // ... your existing hit detection code ...

        requestAnimationFrame(move);
    }

    move();
}
if(playerHP <= 0){
    
    playerAlive = false;
    alert("Game over! You lost.")
    t += 1;

}
function shootOpponentProjectile(ox, oy, dx, dy) {
    const svg = document.getElementById("a");

    const projectile = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    projectile.setAttribute("cx", ox);
    projectile.setAttribute("cy", oy);
    projectile.setAttribute("r", 5);
    projectile.setAttribute("fill", "purple");
    svg.appendChild(projectile);

    const magnitude = Math.sqrt(dx * dx + dy * dy);
    const speed = 4;
    const vx = (dx / magnitude) * speed;
    const vy = (dy / magnitude) * speed;

    function move() {
        let x = parseFloat(projectile.getAttribute("cx"));
        let y = parseFloat(projectile.getAttribute("cy"));

        x += vx;
        y += vy;

        projectile.setAttribute("cx", x);
        projectile.setAttribute("cy", y);

        // Out of bounds
        if (x < 0 || x > 800 || y < 0 || y > 800) {
            svg.removeChild(projectile);
            return;
        }

        // Hit player
        const player = a === "white" ? b : c;
        const px = parseFloat(player.getAttribute("cx"));
        const py = parseFloat(player.getAttribute("cy"));
        const pr = parseFloat(player.getAttribute("r"));

        const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
        if (dist < pr + 5) {
            playerHP--;
            updateHPDisplay();
            svg.removeChild(projectile);

            if (playerHP <= 0) {
                playerAlive = false;
                
                if(t){alert("Game over! You lost.");t=false}
            }

            return;
        }

        requestAnimationFrame(move);
    }

    move();
}
function opponentShootAtPlayer() {
    if (!a || !opponentAlive || !playerAlive) return;

    const opponent = a === "white" ? c : b;
    const player = a === "white" ? b : c;

    const ox = parseFloat(opponent.getAttribute("cx"));
    const oy = parseFloat(opponent.getAttribute("cy"));
    const px = parseFloat(player.getAttribute("cx"));
    const py = parseFloat(player.getAttribute("cy"));

    // Optional: only shoot if line of sight is clear
    if (hasLineOfSight(ox, oy, px, py)) {
        shootOpponentProjectile(ox, oy, px - ox, py - oy);
    }
}
// Add this function to your script
let opponentShootCooldown = false;

function opponentShootAtPlayer() {
    if (!a || !opponentAlive || !playerAlive || opponentShootCooldown) return;

    const opponent = a === "white" ? c : b;
    const player = a === "white" ? b : c;

    const ox = parseFloat(opponent.getAttribute("cx"));
    const oy = parseFloat(opponent.getAttribute("cy"));
    const px = parseFloat(player.getAttribute("cx"));
    const py = parseFloat(player.getAttribute("cy"));

    // Optional: check line of sight before shooting
    if (hasLineOfSight(ox, oy, px, py)) {
        shootOpponentProjectile(ox, oy, px - ox, py - oy);
        // Set cooldown so it doesn't shoot too often
        opponentShootCooldown = true;
        setTimeout(() => { opponentShootCooldown = false; }, 1000); // 1 second cooldown
    }
}

// Modify your startOpponentAI() to include shooting
function startOpponentAI() {
    const interval = 300; // movement interval

    setInterval(() => {
        if (!a || !opponentAlive || !playerAlive) return;

        const opponent = a === "white" ? c : b;
        const player = a === "white" ? b : c;

        const playerCx = parseFloat(player.getAttribute("cx"));
        const playerCy = parseFloat(player.getAttribute("cy"));
        const opponentCx = parseFloat(opponent.getAttribute("cx"));
        const opponentCy = parseFloat(opponent.getAttribute("cy"));
        const radius = parseFloat(opponent.getAttribute("r"));
        const step = 10;

        const dx = playerCx - opponentCx;
        const dy = playerCy - opponentCy;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Move toward the player
        if (dist > radius * 2) {
            let moveX = 0;
            let moveY = 0;

            if (Math.abs(dx) > Math.abs(dy)) {
                moveX = dx > 0 ? step : -step;
            } else {
                moveY = dy > 0 ? step : -step;
            }

            // Dodge logic (optional)
            let dodgeX = 0;
            let dodgeY = 0;
            if (Math.random() < 0.3) { // dodge chance
                if (moveX !== 0) {
                    dodgeY = Math.random() < 0.5 ? -step : step;
                } else if (moveY !== 0) {
                    dodgeX = Math.random() < 0.5 ? -step : step;
                }
            }

            const newCx = opponentCx + moveX + dodgeX;
            const newCy = opponentCy + moveY + dodgeY;

            if (!i(newCx, newCy, radius)) {
                opponent.setAttribute("cx", newCx);
                opponent.setAttribute("cy", newCy);
            } else {
                // fallback movement
                if (!i(opponentCx + moveX, opponentCy + moveY, radius)) {
                    opponent.setAttribute("cx", opponentCx + moveX);
                    opponent.setAttribute("cy", opponentCy + moveY);
                }
            }
        }

        // Call the shooting function periodically
        opponentShootAtPlayer();

    }, interval);
}
function checkProjectileWallCollision(x, y, radius) {
    const walls = document.querySelectorAll("rect");
    for (const wall of walls) {
        if (wall.id.startsWith("wall")) {
            const wx = parseFloat(wall.getAttribute("x"));
            const wy = parseFloat(wall.getAttribute("y"));
            const ww = parseFloat(wall.getAttribute("width"));
            const wh = parseFloat(wall.getAttribute("height"));

            // Find closest point on wall to projectile
            const closestX = Math.max(wx, Math.min(x, wx + ww));
            const closestY = Math.max(wy, Math.min(y, wy + wh));

            const dx = x - closestX;
            const dy = y - closestY;
            if ((dx * dx + dy * dy) < (radius * radius)) {
                // Collision detected
                return true;
            }
        }
    }
    return false;
}
        </script>
    </body>
</html>