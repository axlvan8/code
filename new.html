<!DOCTYPE html>
<html>
<head>
    <title>2D / 3D Battle Game</title>
    <meta charset="UTF-8">
    <style>
        body {
            background: #222;
            color: white;
            font-family: sans-serif;
            text-align: center;
            user-select: none;
        }

        #modeMenu button {
            margin: 20px;
            padding: 20px 40px;
            font-size: 24px;
            cursor: pointer;
        }

        #game2D, #game3D {
            display: none;
            margin-top: 20px;
        }

        #canvas3D {
            background: #88c;
            border: 4px solid white;
        }

        #stats {
            font-size: 20px;
            margin-top: 10px;
        }

        #buildWallBtn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            display: none;
        }

        svg {
            border: 4px solid white;
            background: #5d5;
        }
        .dfs{
            background-color: #222;
            color: #222;
        }
    </style>
    
</head>

<body>

    <h1>2D / 3D Battle Game</h1>

    <!--==========================
        MODE SELECT MENU
    ============================-->
    <div id="modeMenu">
        <p id="margin:center">|</p>
        <button onclick="start2D()">Play 2D Version</button>|
        <button onclick="start3D()">Play 3D Version</button><br>
        <p id="margin:center">|</p><button onclick="load()">load</button>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>
        <p id="margin:center">|</p>

    </div>
    <div id="load">
        <input id="loady" type="text">
        <button onclick="load(document.getElementById('loady'))">load</button>
        <button onclick="document.getElementById('load').style.display='none';document.getElementById('modeMenu').style.display='block'">back</button>
    </div>
    <!--==========================
        2D GAME (SVG)
    ============================-->
    <div id="game2D">
        <svg id="svg2D" width="800" height="800">
            <!-- Player & Opponent -->
            <circle id="player2D" cx="750" cy="750" r="20" fill="white"></circle>
            <circle id="enemy2D" cx="50" cy="50" r="20" fill="black"></circle>

            <!-- Demo walls -->
            <rect x="200" y="200" width="100" height="20" fill="brown"></rect>
            <rect x="400" y="300" width="20" height="100" fill="brown"></rect>
        </svg>

        <div id="stats2D"></div>
        <button id="wallBtn2D" onclick="buildWall2D()">Build Wall</button>
    </div>

    <div id="upgradeMenu" style="display:none; margin-top:20px;">
    <h2>You Win! Upgrade Your Weapon</h2>
    <button onclick="upgradeWeapon()">Upgrade Weapon</button>
    <div id="upgradeInfo"></div><p id="p" class="dfs"></p>
    <button onclick="document.getElementById('p')
    .textContent = `3d;${weapon.color};${ Math.max(200, weapon.cooldown - 50)};${weapon.damage+1};${weapon.length};${weapon.projectileSpeed+0.1};${weapon.radius};${upgradeLevel}`
    ;copyToClipboard('p')">save to clipboard</button>
    <button onclick="const textA=document.getElementById('p').value;
    const blob=new Blob([textA],{type:'text/plain'});">save as text file</button>
    </div>

    <!--==========================
        3D GAME (CANVAS)
    ============================-->
    <div id="game3D">
        <canvas tabindex="0" id="canvas3D" width="900" height="600"></canvas>
        <div id="stats3D"></div>
        <button id="wallBtn3D" onclick="buildWall3D()">Build Wall</button>
    </div>


<script>
    function copyToClipboard(elementId) {
    const el = document.getElementById(elementId);
    if (!el) return;

    const text = el.textContent || el.value;
    if (!text) {
        alert("Nothing to copy.");
        return;
    }

    navigator.clipboard.writeText(text)
        .then(() => {
            
        })
        .catch((err) => {
            console.error("Clipboard error:", err);
            alert("Failed to copy.");
        });
}

    
    var f=false;
    var money = 0;
    
const weapon = {
    length: 0.5,
    radius: 0.08,
    color: "#333",
    damage: 1,
    projectileSpeed: 0.7,
    cooldown: 500
};

let upgradeLevel = 0;

/* ================================================================
    SHARED GAME STATE
================================================================ */
const players = {}; // key: playerID
// each player has joints, position, rotation
function updatePlayerModel(playerID, pos, rot) {
    // Update joints with rotation matrices
    // Draw limbs with cylinder/sphere functions
}
const humanoid = {
    head: {x:0, y:1.8, z:0, r:0.25},
    torso: {x:0, y:1.0, z:0, w:0.5, h:0.8, d:0.3},
    leftArm: {x:-0.4, y:1.4, z:0, length:0.7, radius:0.1, rot:0},
    rightArm: {x:0.4, y:1.4, z:0, length:0.7, radius:0.1, rot:0},
    leftLeg: {x:-0.2, y:0.4, z:0, length:0.8, radius:0.1, rot:0},
    rightLeg: {x:0.2, y:0.4, z:0, length:0.8, radius:0.1, rot:0}
};
function drawCylinder(x1,y1,z1,x2,y2,z2,r,color){
    const steps = 6;
    for(let i=0;i<=steps;i++){
        const t = i/steps;
        drawSphere(
            x1 + (x2-x1)*t,
            y1 + (y2-y1)*t,
            z1 + (z2-z1)*t,
            r,
            color
        );
    }
}

function drawWeapon(handX, handY, handZ, rotY, fire=false) {
    const dx = Math.sin(rotY) * weapon.length;
    const dz = Math.cos(rotY) * weapon.length;

    // weapon barrel
    drawCylinder(
        handX, handY, handZ,
        handX + dx, handY, handZ + dz,
        weapon.radius,
        weapon.color
    );

    // muzzle flash (optional small sphere)
    
    if(fire)drawSphere(handX + dx, handY, handZ + dz, 0.05, "yellow");
}

function getWeaponTip(baseX, baseY, baseZ, rotY) {
    const handX = baseX + Math.sin(rotY) * 0.4;
const handZ = baseZ + Math.cos(rotY) * 0.4;

    const handY = baseY + humanoid.rightArm.y - humanoid.rightArm.length + 0.1;

    

    const muzzleX = handX + Math.sin(rotY) * weapon.length;
    const muzzleY = handY;
    const muzzleZ = handZ + Math.cos(rotY) * weapon.length;

    return {x: muzzleX, y: muzzleY, z: muzzleZ};
}

function drawHumanoid(baseX, baseY, baseZ, rotY, color="skin") {
    const skin = color==="skin" ? "#e0a082" : color;

    // Head
    drawSphere(baseX, baseY + humanoid.head.y, baseZ, humanoid.head.r, skin);

    // Torso
    drawCylinder(
        baseX, baseY + humanoid.torso.y - humanoid.torso.h/2, baseZ,
        baseX, baseY + humanoid.torso.y + humanoid.torso.h/2, baseZ,
        0.25, "#444"
    );

    // Arms
    const leftArmTop = {x: baseX - 0.4, y: baseY + humanoid.leftArm.y, z: baseZ};
    drawCylinder(
        leftArmTop.x, leftArmTop.y, leftArmTop.z,
        leftArmTop.x, leftArmTop.y - humanoid.leftArm.length, leftArmTop.z,
        humanoid.leftArm.radius, skin
    );

    const rightArmTop = {x: baseX + 0.4, y: baseY + humanoid.rightArm.y, z: baseZ};
    drawCylinder(
        rightArmTop.x, rightArmTop.y, rightArmTop.z,
        rightArmTop.x, rightArmTop.y - humanoid.rightArm.length, rightArmTop.z,
        humanoid.rightArm.radius, skin
    );

    // Weapon in right hand
    const handY = rightArmTop.y - humanoid.rightArm.length;
    drawWeapon(rightArmTop.x, handY, rightArmTop.z, rotY);

    // Legs
    drawCylinder(
        baseX - 0.2, baseY + humanoid.leftLeg.y, baseZ,
        baseX - 0.2, baseY + humanoid.leftLeg.y - humanoid.leftLeg.length, baseZ,
        humanoid.leftLeg.radius, skin
    );

    drawCylinder(
        baseX + 0.2, baseY + humanoid.rightLeg.y, baseZ,
        baseX + 0.2, baseY + humanoid.rightLeg.y - humanoid.rightLeg.length, baseZ,
        humanoid.rightLeg.radius, skin
    );
}

let mode = null;             // "2D" or "3D"
let playerHP = 3;
let enemyHP = 3;

let canShoot = true;
const shootCooldown = 500;

let enemyAlive = true;
let playerAlive = true;

let facing2D = "up"; // For building walls in 2D


/* ================================================================
    MODE SELECTION
================================================================ */

function start2D() {
    mode = "2D";
    document.getElementById("modeMenu").style.display = "none";
    document.getElementById("game2D").style.display = "block";
    document.getElementById("wallBtn2D").style.display = "inline-block";

    resetSharedState();
    init2D();
}

function start3D() {
    mode = "3D";
    document.getElementById("modeMenu").style.display = "none";
    document.getElementById("game3D").style.display = "block";
    document.getElementById("wallBtn3D").style.display = "inline-block";

    resetSharedState();
    init3D();
}

function resetSharedState() {
    playerHP = 3;
    enemyHP = 3;
    enemyAlive = true;
    playerAlive = true;
}


/* ================================================================
    2D GAME ENGINE
================================================================ */

let svg, player2D, enemy2D;

function init2D() {
    svg = document.getElementById("svg2D");
    player2D = document.getElementById("player2D");
    enemy2D = document.getElementById("enemy2D");

    updateStats2D();
    document.addEventListener("keydown", handle2DKeys);

    setInterval(enemyAI2D, 300);
}

function updateStats2D() {
    document.getElementById("stats2D").innerHTML =
        `Player HP: ${playerHP} | Enemy HP: ${enemyHP}`;
}

function handle2DKeys(e) {
    if (!playerAlive || !enemyAlive) return;

    let cx = parseInt(player2D.getAttribute("cx"));
    let cy = parseInt(player2D.getAttribute("cy"));
    const step = 10;

    if (e.key === "w") { cy -= step; facing2D = "up"; }
    if (e.key === "s") { cy += step; facing2D = "down"; }
    if (e.key === "a") { cx -= step; facing2D = "left"; }
    if (e.key === "d") { cx += step; facing2D = "right"; }

    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
        shoot2D(e.key);
        return;
    }

    if (!hitsWall2D(cx,cy,20)) {
        player2D.setAttribute("cx", cx);
        player2D.setAttribute("cy", cy);
    }
}

function hitsWall2D(x,y,r) {
    const walls = svg.querySelectorAll("rect");
    for (const wall of walls) {
        const wx = +wall.getAttribute("x");
        const wy = +wall.getAttribute("y");
        const ww = +wall.getAttribute("width");
        const wh = +wall.getAttribute("height");

        const closestX = Math.max(wx, Math.min(x, wx+ww));
        const closestY = Math.max(wy, Math.min(y, wy+wh));

        if ((x - closestX)**2 + (y - closestY)**2 < r*r) return true;
    }
    return false;
}

function buildWall2D() {
    const cx = +player2D.getAttribute("cx");
    const cy = +player2D.getAttribute("cy");

    let wx = cx, wy = cy;
    const W = 40, H = 10;

    if (facing2D === "up")    { wx = cx-W/2; wy = cy-30; }
    if (facing2D === "down")  { wx = cx-W/2; wy = cy+30; }
    if (facing2D === "left")  { wx = cx-30; wy = cy-W/2; }
    if (facing2D === "right") { wx = cx+30; wy = cy-W/2; }

    const wall = document.createElementNS("http://www.w3.org/2000/svg","rect");
    wall.setAttribute("x", wx);
    wall.setAttribute("y", wy);
    wall.setAttribute("width", facing2D==="left"||facing2D==="right"?H:W);
    wall.setAttribute("height", facing2D==="left"||facing2D==="right"?W:H);
    wall.setAttribute("fill","brown");

    svg.appendChild(wall);
}

function shoot2D(direction) {
    if (!canShoot) return;
    canShoot = false;
    setTimeout(()=>canShoot=true, weapon.cooldown);

    const px = +player2D.getAttribute("cx");
    const py = +player2D.getAttribute("cy");

    const proj = document.createElementNS("http://www.w3.org/2000/svg","circle");
    proj.setAttribute("cx", px);
    proj.setAttribute("cy", py);
    proj.setAttribute("r", 5);
    proj.setAttribute("fill", "red");
    svg.appendChild(proj);

    let dx=0, dy=0;
    if (direction==="ArrowUp") dy=-5;
    if (direction==="ArrowDown") dy=5;
    if (direction==="ArrowLeft") dx=-5;
    if (direction==="ArrowRight") dx=5;

    function move() {
        let x = +proj.getAttribute("cx") + dx;
        let y = +proj.getAttribute("cy") + dy;

        if (hitsWall2D(x,y,5)) { proj.remove(); return; }

        proj.setAttribute("cx", x);
        proj.setAttribute("cy", y);

        if (x<0||x>800||y<0||y>800) { proj.remove(); return; }

        const ex = +enemy2D.getAttribute("cx");
        const ey = +enemy2D.getAttribute("cy");
        const er = +enemy2D.getAttribute("r");

        if ((x-ex)**2 + (y-ey)**2 < (er+5)**2) {
            enemyHP-=weapon.damage;
            updateStats2D();
            proj.remove();
            if (enemyHP<=0 && enemyAlive) {
                enemyAlive = false;
                onPlayerWin();

            }
            return;
        }

        requestAnimationFrame(move);
    }
    move();
}

/* =======================
   2D AI
======================= */
function enemyAI2D() {
    if (!enemyAlive || !playerAlive) return;

    const ex = +enemy2D.getAttribute("cx");
    const ey = +enemy2D.getAttribute("cy");
    const px = +player2D.getAttribute("cx");
    const py = +player2D.getAttribute("cy");

    const dx = px - ex;
    const dy = py - ey;
    const step = 10;

    let mx=0,my=0;
    if (Math.abs(dx) > Math.abs(dy)) mx = dx>0 ? step : -step;
    else my = dy>0 ? step : -step;

    const nx = ex + mx;
    const ny = ey + my;

    if (!hitsWall2D(nx,ny,20)) {
        enemy2D.setAttribute("cx",nx);
        enemy2D.setAttribute("cy",ny);
    }

    shootEnemy2D();
}

function shootEnemy2D() {
    if (Math.random()<0.97) return; // reduces spam

    const ex = +enemy2D.getAttribute("cx");
    const ey = +enemy2D.getAttribute("cy");

    const px = +player2D.getAttribute("cx");
    const py = +player2D.getAttribute("cy");

    const dx = px-ex, dy = py-ey;
    const mag = Math.sqrt(dx*dx + dy*dy);
    if (mag<0.1) return;

    const spd = 4;
    const vx = dx/mag * spd;
    const vy = dy/mag * spd;

    const proj = document.createElementNS("http://www.w3.org/2000/svg","circle");
    proj.setAttribute("cx", ex);
    proj.setAttribute("cy", ey);
    proj.setAttribute("r", 5);
    proj.setAttribute("fill", "purple");
    svg.appendChild(proj);

    function move() {
        let x = +proj.getAttribute("cx") + vx;
        let y = +proj.getAttribute("cy") + vy;

        if (hitsWall2D(x,y,5)) { proj.remove(); return; }

        proj.setAttribute("cx", x);
        proj.setAttribute("cy", y);

        if ((x-px)**2 + (y-py)**2 < (20+5)**2) {
            playerHP-=weapon.damage;
            updateStats2D();
            proj.remove();
            if (playerHP<=0 && playerAlive) {
                playerAlive = false;
                alert("You LOST!");
            }
            return;
        }

        requestAnimationFrame(move);
    }
    move();
}

/* ================================================================
    3D GAME ENGINE
================================================================ */

let canvas3D, ctx3D;

let cam = {
    x:0, y:1.7, z:0,
    rotY:0,
    rotX:0
};

let enemy3D = { x: -10, z: -10 };
let walls3D = [];

/* -----------------------------
    TERRAIN GENERATION
----------------------------- */

const terrain = [];
const terrainSize = 40;

for (let x=-terrainSize; x<=terrainSize; x++) {
    terrain[x] = [];
    for (let z=-terrainSize; z<=terrainSize; z++) {
        const h =
            Math.sin(x*0.3)*0.3 +
            Math.cos(z*0.3)*0.3 +
            Math.random()*0.1;
        terrain[x][z] = h;
    }
}

function getHeight(x,z) {
    const xi = Math.floor(x);
    const zi = Math.floor(z);
    if (terrain[xi] && terrain[xi][zi] !== undefined)
        return terrain[xi][zi];
    return 0;
}
/* ================================================================
    POINTER LOCK + MOUSE LOOK
================================================================ */

let pointerLocked = false;

function enablePointerLock() {
    canvas3D.requestPointerLock =
        canvas3D.requestPointerLock ||
        canvas3D.mozRequestPointerLock ||
        canvas3D.webkitRequestPointerLock;

    canvas3D.requestPointerLock();
}

// When pointer lock is acquired
document.addEventListener("pointerlockchange", () => {
    pointerLocked = (document.pointerLockElement === canvas3D);
});

// Mouse movement rotates camera
document.addEventListener("mousemove", (e) => {
    if (!pointerLocked || mode !== "3D") return;

    const sensitivity = 0.002;

    cam.rotY += e.movementX * sensitivity;      // left/right
    cam.rotX -= e.movementY * sensitivity;      // up/down  (invert for FPS feel)

    // clamp so player cannot flip upside-down
    cam.rotX = Math.max(-1.3, Math.min(1.3, cam.rotX));
});


/* -----------------------------
    INIT 3D
----------------------------- */
function init3D() {
    

    canvas3D = document.getElementById("canvas3D");
    ctx3D = canvas3D.getContext("2d");
    canvas3D.addEventListener("click", enablePointerLock);
    cam.x = 20;
    cam.z = 20;
    cam.y = getHeight(cam.x,cam.z) + 1.7;

    enemy3D.x = -20;
    enemy3D.z = -20;

    document.addEventListener("keydown", key3D);

    update3D();
    setInterval(ai3D, 300);
}
/*function rotateLimb(p1, p2, rotationMatrix) {
    ctx.fillStyle = ctx.createLinearGradient(px1, py1, px2, py2);
ctx.fillStyle.addColorStop(0, "#e0a082");
ctx.fillStyle.addColorStop(1, "#c07050");
ctx.fill();

}*/

function key3D(e) {
    if (!playerAlive || !enemyAlive) return;

    const spd = 0.4;
    if(e.key==="b")buildWall3D();
    if (e.key==="a") cam.rotY -= 0.1;
    if (e.key==="d") cam.rotY += 0.1;

    if (e.key==="w") {
        cam.x += Math.sin(cam.rotY) * spd;
        cam.z += Math.cos(cam.rotY) * spd;
    }
    if (e.key==="s") {
        cam.x -= Math.sin(cam.rotY) * spd;
        cam.z -= Math.cos(cam.rotY) * spd;
    }

    cam.y = getHeight(cam.x,cam.z) + 1.7;

    if (["f","F"].includes(e.key))
        shoot3D(e.key);
}

/* -----------------------------
    PROJECTION
----------------------------- */
function project3D(x, y, z) {
    let dx = x - cam.x;
    let dy = y - cam.y;
    let dz = z - cam.z;

    // Y rotation (turn left/right)
    const sy = Math.sin(cam.rotY), cy = Math.cos(cam.rotY);
    let rx = dx * cy - dz * sy;
    let rz = dx * sy + dz * cy;

    // X rotation (look up/down)
    const sx = Math.sin(cam.rotX), cx = Math.cos(cam.rotX);
    let ry = dy * cx - rz * sx;
    rz = dy * sx + rz * cx;

    if (rz < 0.1) return null;

    const scale = 400 / rz;

    return {
        x: 450 + rx * scale,
        y: 300 - ry * scale,
        d: rz
    };
}


/* -----------------------------
    DRAW TERRAIN (TRIANGLE MESH)
----------------------------- */

function drawTerrain() {
    ctx3D.fillStyle = "#55aa55";
    ctx3D.strokeStyle = "#225522";
    const viewDist = 40;
    for (let x=-viewDist; x<viewDist; x++) {
        for (let z=-terrainSize; z<terrainSize; z++) {

            const h1 = terrain[x][z];
            const h2 = terrain[x+1][z];
            const h3 = terrain[x][z+1];
            const h4 = terrain[x+1][z+1];

            const p1 = project3D(x, h1, z);
            const p2 = project3D(x+1, h2, z);
            const p3 = project3D(x, h3, z+1);
            const p4 = project3D(x+1, h4, z+1);

            if (!p1||!p2||!p3||!p4) continue;

            ctx3D.beginPath();
            ctx3D.moveTo(p1.x, p1.y);
            ctx3D.lineTo(p2.x, p2.y);
            ctx3D.lineTo(p4.x, p4.y);
            ctx3D.lineTo(p3.x, p3.y);
            ctx3D.closePath();

            ctx3D.fill();
            ctx3D.stroke();
        }
    }
}

/* -----------------------------
    DRAW SPHERE (PLAYER BULLETS / ENEMY)
----------------------------- */

function drawSphere(x,y,z,r,color) {
    const p = project3D(x,y,z);
    if (!p) return;

    const size = 200 / p.d;
    ctx3D.fillStyle = color;
    ctx3D.beginPath();
    ctx3D.arc(p.x, p.y, size*r, 0, Math.PI*2);
    ctx3D.fill();
}

/* -----------------------------
    PLAYER SHOOTING 3D
----------------------------- */

let projectiles3D = [];

function shoot3D(key) {
    if (!canShoot) return;
    canShoot = false;
    setTimeout(()=>canShoot=true, shootCooldown);

    // Player weapon muzzle position
    const tip = getWeaponTip(
        cam.x,
        getHeight(cam.x, cam.z) + 0.1,
        cam.z,
        cam.rotY
    );
    
    const dx = Math.sin(cam.rotY);
    const dz = Math.cos(cam.rotY);

    projectiles3D.push({
        x: tip.x,
        y: tip.y,
        z: tip.z,
        dx: dx,
        dz: dz,
        alive: true
    });
}


function updateProjectiles3D() {
    const spd = 4;

    for (let p of projectiles3D) {
        if (!p.alive) continue;

        p.x += p.dx * spd;
        p.z += p.dz * spd;
        p.y = getHeight(p.x,p.z) + 1.7;

        if (p.x<-50||p.x>50||p.z<-50||p.z>50)
            p.alive=false;

        const dx = p.x - enemy3D.x;
        const dz = p.z - enemy3D.z;
        if (dx*dx + dz*dz < 1) {
            enemyHP--;
            p.alive=false;
            if (enemyHP<=0 && enemyAlive) {
                enemyAlive=false;
                onPlayerWin();

            }
        }
    }for (let w of walls3D) {
    const dx = p.x - w.x;
    const dz = p.z - w.z;
    if (dx*dx + dz*dz < 1) {
        p.alive = false;
        continue;
    }
}

    
    projectiles3D = projectiles3D.filter(p=>p.alive);
}

/* -----------------------------
    ENEMY AI (3D)
----------------------------- */

let enemyProjectiles3D = [];

function ai3D() {
    if (!enemyAlive || !playerAlive) return;

    const dx = cam.x - enemy3D.x;
    const dz = cam.z - enemy3D.z;
    const dist = Math.sqrt(dx*dx + dz*dz);

    const step = 0.5;
    if (dist > 2) {
        enemy3D.x += dx/dist * step;
        enemy3D.z += dz/dist * step;
    }

    if (Math.random() < 0.1) shootEnemy3D();
}

function shootEnemy3D() {
    const baseY = getHeight(enemy3D.x, enemy3D.z) + 0.1;
    const rot = Math.atan2(cam.x - enemy3D.x, cam.z - enemy3D.z);
const tip = getWeaponTip(enemy3D.x, baseY, enemy3D.z, rot);


    const dx = cam.x - tip.x;
    const dz = cam.z - tip.z;
    const mag = Math.sqrt(dx*dx + dz*dz);
    if (mag < 0.1) return;

    enemyProjectiles3D.push({
        x: tip.x,
        y: tip.y,
        z: tip.z,
        dx: dx/mag,
        dz: dz/mag,
        alive: true
    });
}


function updateEnemyProjectiles3D() {
    const spd = 0.5;
    for (let p of enemyProjectiles3D) {
        if (!p.alive) continue;

        p.x += p.dx * spd;
        p.z += p.dz * spd;
        p.y = getHeight(p.x,p.z)+1.7;

        if (Math.abs(p.x-cam.x)<0.7 && Math.abs(p.z-cam.z)<0.7) {
            playerHP--;
            p.alive=false;
            if (playerHP<=0 && playerAlive) {
                playerAlive=false;
                alert("YOU LOST!");
            }
        }
    }
    enemyProjectiles3D = enemyProjectiles3D.filter(p=>p.alive);
}

/* -----------------------------
    WALLS IN 3D
----------------------------- */
function buildWall3D() {
    const x = cam.x + Math.sin(cam.rotY)*2;
    const z = cam.z + Math.cos(cam.rotY)*2;

    walls3D.push({x,z,h:1});
}

function drawWalls3D() {
    for (let w of walls3D) {
        w.y=getHeight(w.x,w.z)+1;
       drawCylinder(w.x, w.y, w.z, w.x, w.y + w.h, w.z, 0.3, "brown");

    }
}

/* -----------------------------
    UPDATE LOOP (3D)
----------------------------- */
var dg=false;
var gd = 0;
function update3D() {
    if(!dg){
    ctx3D.clearRect(0,0,900,600);

    drawTerrain();
    const enemyAngle = Math.atan2(cam.x - enemy3D.x, cam.z - enemy3D.z);
drawHumanoid(enemy3D.x, getHeight(enemy3D.x, enemy3D.z)+0.1, enemy3D.z, enemyAngle, "black");

    drawWalls3D();

    updateProjectiles3D();
    updateEnemyProjectiles3D();

    for (let p of projectiles3D)
        drawSphere(p.x, p.y, p.z, 0.1, "red");

    for (let p of enemyProjectiles3D)
        drawSphere(p.x, p.y, p.z, 0.1, "purple");
        drawCrosshair()}
    document.getElementById("stats3D").innerHTML =
        `Player HP: ${playerHP} | Enemy HP: ${enemyHP} | $: ${money}`;
    
    
    if(enemyHP===0&&playerHP!=0){
        if(f!==true){
            money+=50;
        }
        f=true

        
       ctx3D.fillStyle = "white";
ctx3D.fillRect(0,0,900,600);
ctx3D.fillStyle = "black";
ctx3D.font = "50px sans-serif";
ctx3D.fillText("YOU WIN!", 300, 300);

    }
    requestAnimationFrame(update3D);
}

/* ================================================================
    CROSSHAIR
================================================================ */

function drawCrosshair() {
    const w = canvas3D.width;
    const h = canvas3D.height;

    const size = 15;
    ctx3D.strokeStyle = "white";
    ctx3D.lineWidth = 2;

    ctx3D.beginPath();
    // horizontal
    ctx3D.moveTo(w/2 - size, h/2);
    ctx3D.lineTo(w/2 + size, h/2);
    // vertical
    ctx3D.moveTo(w/2, h/2 - size);
    ctx3D.lineTo(w/2, h/2 + size);

    ctx3D.stroke();
}
function onPlayerWin() {
    document.getElementById("upgradeMenu").style.display = "block";

    document.getElementById("upgradeInfo").innerHTML =
        `Current Level: ${upgradeLevel}<br>
        Damage: ${weapon.damage}<br>
        Fire Rate: ${(1000/weapon.cooldown).toFixed(2)} shots/sec<br>
        Projectile Speed: ${weapon.projectileSpeed}<br>`;
}
function upgradeWeapon() {
    upgradeLevel++;
     weapon.damage += 1;
    weapon.projectileSpeed += 0.1;
    weapon.cooldown = Math.max(200, weapon.cooldown - 50);

    // Improve stats
    if(upgradeLevel==2){
        weapon.length=7.62;
        weapon.color="#333"
        weapon.cooldown=1.6;//AK-47
    }
   
    document.getElementById("upgradeInfo").innerHTML =
        `<b>Upgraded</b><br>
        Level: ${upgradeLevel}<br>
        Damage: ${weapon.damage}<br>
        Fire Rate: ${(1000/weapon.cooldown).toFixed(2)} RPM<br>
        Projectile Speed: ${weapon.projectileSpeed}`;

    // Hide after upgrade
    setTimeout(() => {
        document.getElementById("upgradeMenu").style.display = "none";
    }, 1500);
}
function load(b=""){
    document.getElementById("modeMenu").style.display = "none";
    document.getElementById("load").style.display = "block";
    if(b){
        if(b.trim()!==""){
            var kjhg=[];
            var gjjh=0;
            var hjhb=false;
            var ghgf='';
            for(var i=0;i<b.length;i++){
                if(b[i]==';'){
                    hjhb=true;
                    kjhg.push(ghgf);
                    ghgf=''
                    gjjh++
                }
                if(b[i]!==';'){
                    if(!hjhb){
                        ghgf=ghgf.concat(b[i])
                    }
                }

            }
            for(var j=0;j<kjhg.length;j++){
                if(j===1){
                    weapon.color=kjhg[j];
                }
                if(j===2){
                    weapon.cooldown=parseInt(kjhg[j])
                }
                if(j===3){
                    weapon.damage=parseInt(kjhg[j])
                }
                if(j===4){
                    weapon.length=parseInt(kjhg[j])
                }
                if(j===5){
                    weapon.projectileSpeed=parseInt(kjhg[j])
                }

            }
        }
        return;
    }
    return;
}
</script>

</body>
</html>
