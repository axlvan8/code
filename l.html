<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>3D Life Simulation â€“ Villagers Build Structures</title>
<style>
body { margin: 0; overflow: hidden; background: black; }
canvas { display:block; margin:auto; background: linear-gradient(#66aaff, #004); }
</style>
</head>
<body>
<canvas id="canvas" width="900" height="700"></canvas>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let W = canvas.width, H = canvas.height;

// ===== TERRAIN =====
const terrain = [];
const terrainSize = 40;
for(let x=-terrainSize; x<=terrainSize; x++){
  terrain[x] = [];
  for(let z=-terrainSize; z<=terrainSize; z++){
    const h = Math.sin(x*0.3)*0.3 + Math.cos(z*0.3)*0.3 + Math.random()*0.1;
    terrain[x][z] = h;
  }
}
function getHeight(x,z){
  const xi = Math.floor(x), zi = Math.floor(z);
  if(terrain[xi] && terrain[xi][zi] !== undefined) return terrain[xi][zi];
  return 0;
}

// ===== CAMERA =====
let camera = { pos:[0,1.5,-6], rot:[0,0] };
const keys = {};
document.addEventListener("keydown", e=>keys[e.key.toLowerCase()]=true);
document.addEventListener("keyup", e=>keys[e.key.toLowerCase()]=false);
canvas.addEventListener("click", ()=>canvas.requestPointerLock());
document.addEventListener("mousemove", e=>{
  if(document.pointerLockElement===canvas){
    camera.rot[1] -= e.movementX * 0.002;
    camera.rot[0] -= e.movementY * 0.002;
    camera.rot[0] = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rot[0]));
  }
});

// ===== PHYSICS =====
let playerVelY = 0;
const gravity = -0.01;
const jumpStrength = 0.2;
let isOnGround = true;

// ===== PROJECTION =====
function project([x,y,z]){
  let [cx,cy,cz]=camera.pos;
  z = Math.max(z, 0.01);

  x-=cx; y-=cy; z-=cz;

  // yaw
  const yaw=camera.rot[1];
  const cosY=Math.cos(yaw), sinY=Math.sin(yaw);
  let xz = x*cosY - z*sinY;
  let zz = x*sinY + z*cosY;
  x=xz; z=zz;

  // pitch
  const pitch=camera.rot[0];
  const cosX=Math.cos(pitch), sinX=Math.sin(pitch);
  let yz = y*cosX - z*sinX;
  let zz2 = y*sinX + z*cosX;
  y=yz; z=zz2;

  // Use a smaller near plane, e.g., 0.01 instead of 0.2
  if(z < 0.01) return null;

  const scale = 400/(z+6);
  return [x*scale + W/2, -y*scale + H/2];
}

// ===== SHAPES =====
function hexToRgb(hex){
  hex = hex.replace('#','');
  const bigint = parseInt(hex,16);
  return [(bigint>>16)&255, (bigint>>8)&255, bigint&255];
}
function drawCube(pos,size,color){
  const s=size;
  const verts=[
    [-s,-s,-s],[s,-s,-s],[s,s,-s],[-s,s,-s],
    [-s,-s,s],[s,-s,s],[s,s,s],[-s,s,s]
  ].map(([x,y,z])=>[pos[0]+x,pos[1]+y,pos[2]+z]);

  const faces=[
    {idx:[0,1,2,3], normal:[0,0,-1]},
    {idx:[4,5,6,7], normal:[0,0,1]},
    {idx:[0,1,5,4], normal:[0,-1,0]},
    {idx:[2,3,7,6], normal:[0,1,0]},
    {idx:[1,2,6,5], normal:[1,0,0]},
    {idx:[0,3,7,4], normal:[-1,0,0]}
  ];

  const lightDir=[0.5,0.7,1];
  const len=Math.hypot(...lightDir);
  lightDir[0]/=len;lightDir[1]/=len;lightDir[2]/=len;

  const facesToDraw=[];
  for(let f of faces){
    const pts=f.idx.map(i=>project(verts[i]));
    if(pts.includes(null)) continue;
    const avgZ=pts.reduce((a,p)=>a+p[1],0)/pts.length;
    facesToDraw.push({f,pts,avgZ});
  }
  facesToDraw.sort((a,b)=>b.avgZ - a.avgZ);

  for(let {f,pts} of facesToDraw){
    const dot=Math.max(0,f.normal[0]*lightDir[0]+f.normal[1]*lightDir[1]+f.normal[2]*lightDir[2]);
    const shade=0.4+dot*0.6;
    const [r,g,b]=hexToRgb(color);
    ctx.fillStyle=`rgb(${r*shade},${g*shade},${b*shade})`;
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.2)";
    ctx.stroke();
  }
}

// ===== HUMAN =====
function drawHuman(pos,scale,rotY,color,t){
  const headH=0.25*scale, bodyH=0.8*scale, legH=0.7*scale, armL=0.6*scale;
  const base=[pos[0],pos[1]+legH,pos[2]];
  const legSwing=Math.sin(t*5)*0.3;
  const armSwing=Math.sin(t*5+Math.PI)*0.3;

  const torsoTop=[0,bodyH,0], torsoBottom=[0,0,0];
  const lS=[-0.25*scale,bodyH,0], rS=[0.25*scale,bodyH,0];
  const lH=[-0.25*scale,bodyH-0.5*scale,armL*Math.sin(armSwing)];
  const rH=[0.25*scale,bodyH-0.5*scale,-armL*Math.sin(armSwing)];
  const lHip=[-0.15*scale,0,0], rHip=[0.15*scale,0,0];
  const lF=[-0.15*scale,-legH*Math.cos(legSwing),legH*Math.sin(legSwing)];
  const rF=[0.15*scale,-legH*Math.cos(-legSwing),legH*Math.sin(-legSwing)];

  function RY(p){const c=Math.cos(rotY),s=Math.sin(rotY);return [p[0]*c-p[2]*s,p[1],p[0]*s+p[2]*c];}
  function add(a,b){return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
  function bone(a,b){
    const pa=project(a),pb=project(b);
    if(!pa||!pb) return;
    ctx.strokeStyle=color;ctx.lineWidth=2;
    ctx.beginPath();ctx.moveTo(...pa);ctx.lineTo(...pb);ctx.stroke();
  }
  const pts={lS:add(RY(lS),base),rS:add(RY(rS),base),lH:add(RY(lH),base),rH:add(RY(rH),base),
             lHip:add(RY(lHip),base),rHip:add(RY(rHip),base),lF:add(RY(lF),base),rF:add(RY(rF),base),
             torsoTop:add(RY(torsoTop),base),torsoBottom:add(RY(torsoBottom),base)};
  bone(pts.torsoTop,pts.torsoBottom);
  bone(pts.lS,pts.lH);bone(pts.rS,pts.rH);
  bone(pts.lHip,pts.lF);bone(pts.rHip,pts.rF);
  const head=project(add(RY([0,bodyH+headH,0]),base));
  if(head){ctx.fillStyle=color;ctx.beginPath();ctx.arc(head[0],head[1],5*scale,0,Math.PI*2);ctx.fill();}
}

// ===== ENTITIES =====
class Food{constructor(x,z){this.pos=[x,0,z];}}
class Structure{constructor(x,z,tribe){this.pos=[x,0,z];this.tribe=tribe;this.color=tribe==="red"?"#aa4444":"#44aa44";}}
class Camp{constructor(x,z,tribe){this.pos=[x,getHeight(x,z),z];this.tribe=tribe;this.color=tribe==="red"?"darkred":"darkgreen";this.structures=[];}}
class Tree{constructor(x,z){this.pos=[x,getHeight(x,z),z];this.height=0.8+Math.random()*0.5;this.resources=3+Math.random()*2;this.color="#228833";}}
class Rock{constructor(x,z){this.pos=[x,getHeight(x,z),z];this.size=0.3+Math.random()*0.2;this.resources=3+Math.random()*2;this.color="#777";}}
function distance(a,b){const dx=a[0]-b[0],dz=a[2]-b[2];return Math.sqrt(dx*dx+dz*dz);}

class Creature{
 constructor(x,z,tribe="red",isPlayer=false,home=null){
   this.pos=[x,getHeight(x,z),z];
   this.energy=100;this.wood=0;this.stone=0;
   this.tribe=tribe;this.color=tribe==="red"?"crimson":"lime";
   this.isPlayer=isPlayer;this.cooldown=0;this.home=home;
   this.rotationY=0;this.lastPos=[x,z];
 }
 update(world){
   if(this.isPlayer){
     const speed=0.1;const yaw=camera.rot[1];
     let vx=0,vz=0;
     if(keys["w"]){vx+=Math.sin(yaw)*speed;vz+=Math.cos(yaw)*speed;}
     if(keys["s"]){vx-=Math.sin(yaw)*speed;vz-=Math.cos(yaw)*speed;}
     if(keys["a"]){vx-=Math.cos(yaw)*speed;vz+=Math.sin(yaw)*speed;}
     if(keys["d"]){vx+=Math.cos(yaw)*speed;vz-=Math.sin(yaw)*speed;}
     this.pos[0]+=vx;this.pos[2]+=vz;
     playerVelY+=gravity;
     this.pos[1]+=playerVelY;
     const groundH=getHeight(this.pos[0],this.pos[2]);
     if(this.pos[1]<=groundH){
       this.pos[1]=groundH;playerVelY=0;isOnGround=true;
     }else isOnGround=false;
     if(keys[" "]&&isOnGround){playerVelY=jumpStrength;isOnGround=false;}
     camera.pos=[
       this.pos[0]-Math.sin(camera.rot[1])*1.5,
       this.pos[1]+1.2,
       this.pos[2]-Math.cos(camera.rot[1])*1.5
     ];
     return;
   }

   // Simple AI
   this.energy-=0.02;
   if(this.energy<=0) return;
   this.pos[0]+=(Math.random()-0.5)*0.05;
   this.pos[2]+=(Math.random()-0.5)*0.05;
   const dx=this.pos[0]-this.lastPos[0],dz=this.pos[2]-this.lastPos[1];
   if(Math.abs(dx)+Math.abs(dz)>0.001)this.rotationY=Math.atan2(dx,dz);
   this.lastPos=[this.pos[0],this.pos[2]];
 }
}

// ===== WORLD =====
const world={player:new Creature(0,0,"cyan",true),creatures:[],food:[],camps:[],structures:[]};
const campRed=new Camp(-10,10,"red"),campGreen=new Camp(10,10,"green");
world.camps.push(campRed,campGreen);
for(let i=0;i<8;i++)world.creatures.push(new Creature(campRed.pos[0]+Math.random()-0.5,campRed.pos[2]+Math.random()-0.5,"red",false,campRed));
for(let i=0;i<8;i++)world.creatures.push(new Creature(campGreen.pos[0]+Math.random()-0.5,campGreen.pos[2]+Math.random()-0.5,"green",false,campGreen));
world.trees=[];world.rocks=[];
for(let i=0;i<50;i++){const x=Math.random()*40-20,z=Math.random()*40/20;if(Math.random()<0.6)world.trees.push(new Tree(x,z));else world.rocks.push(new Rock(x,z));}

let time=0;

// ===== LOOP =====
function loop(){
  ctx.clearRect(0,0,W,H);
  // terrain
  for(let x=-terrainSize; x<terrainSize; x++){
    for(let z=-terrainSize; z<terrainSize; z++){
      const h=terrain[x][z];
      const p=project([x,h,z]); if(!p) continue;
      ctx.fillStyle = h>0.3?"#558844":h>0?"#447744":"#335533";
      ctx.fillRect(p[0],p[1],2,2);
    }
  }

  // draw trees & rocks
  for(let t of world.trees){
    if(t.resources<=0) continue;
    const top=project([t.pos[0],t.pos[1]+t.height,t.pos[2]]);
    const base=project([t.pos[0],t.pos[1],t.pos[2]]);
    if(!top||!base) continue;
    ctx.strokeStyle=t.color;ctx.lineWidth=4;
    ctx.beginPath();ctx.moveTo(...top);ctx.lineTo(...base);ctx.stroke();
  }
  for(let r of world.rocks){if(r.resources>0)drawCube(r.pos,r.size*(r.resources/5),"#777");}

  // camps, structures, food
  for(let camp of world.camps)drawCube(camp.pos,0.8,camp.color);
  for(let s of world.structures)drawCube(s.pos,0.6,s.color);
  for(let f of world.food)drawCube(f.pos,0.1,"yellow");

  time+=0.01;
  world.player.update(world);
  for(let c of world.creatures)c.update(world);

  drawHuman(world.player.pos,0.7,camera.rot[1],"cyan",time);
  for(let c of world.creatures)drawHuman(c.pos,0.6,c.rotationY,c.color,time+c.pos[0]);

  ctx.fillStyle="white";ctx.font="16px monospace";
  ctx.fillText(`Creatures: ${world.creatures.length}`,20,30);
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
