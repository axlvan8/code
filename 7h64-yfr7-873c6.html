<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Raycaster Survival Demo</title>
<style>
  body {
    margin: 0;
    background: black;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    cursor: crosshair;
  }
  canvas { image-rendering: pixelated; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = 640;
canvas.height = 480;

const FOV = Math.PI / 3;
const RES = 4;
const RAYS = canvas.width / RES;
const STEP = 0.02;

// ===== HELPERS =====
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function isWall(x, y) {
  const mx = Math.floor(x), my = Math.floor(y);
  if (my < 0 || my >= map.length) return true;
  if (mx < 0 || mx >= map[0].length) return true;
  return map[my][mx] === "#";
}
function castRay(angle) {
  let x = player.x, y = player.y;
  while (!isWall(x, y) && Math.hypot(x - player.x, y - player.y) < 50) {
    x += Math.cos(angle) * STEP;
    y += Math.sin(angle) * STEP;
  }
  return Math.hypot(x - player.x, y - player.y);
}
function healthPulse() {
  const h = clamp(player.health || 100, 0, 100) / 100;
  const speed = 1.2 + (1 - h) * 3.5;
  const strength = (1 - h) * 0.12;
  return 1 + Math.sin(performance.now() * 0.001 * speed) * strength;
}

// ===== MAP =====
const map = [
  "############################################",
  "#..........................................#",
  "#....#####################################.#",
  "#....#.....................................#",
  "#....#.....................................#",
  "#....#...........#.....###################.#",
  "#....#...........#.......................#.#",
  "#....#...........#.....#.................#.#",
  "#....#...........#.....#.........####....#.#",
  "#....#...........#.....#........######...#.#",
  "#....#...........#.....#.........####....#.#",
  "#................#.....#.................#.#",
  "#....#...........#.....#.................#.#",
  "#....#...........#.....#...................#",
  "#....#...........#.....#...................#",
  "#....#...........#.........................#",
  "#....#...........#.....######..#####.......#",
  "#....#...........#.....#...........#.......#",
  "#....#...........#.....#############.......#",
  "#....#.....................................#",
  "#....########################..............#",
  "#..........................................#",
  "############################################"
];

// ===== PLAYER =====
const player = { x: 3, y: 2, angle: 0, speed: 0.05, health: 100 };

// ===== FLASHLIGHT =====
const flashlight = { power: 1, battery: 100, drainRate: 0.02 };

// ===== ENEMIES & FOG =====
const enemies = [{ x: 6.5, y: 3.5, size: 0.4 }, { x: 10.2, y: 6.8, size: 0.5 }];
const fogParticles = Array.from({ length: 120 }, () => ({ a: Math.random(), d: Math.random(), s: 0.002 + Math.random() * 0.004 }));

let smoothRadiusFactor = 1;

// ===== INPUT =====
const keys = {};
addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
canvas.addEventListener("click", () => canvas.requestPointerLock());
document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === canvas) player.angle += e.movementX * 0.002;
});

// ===== ENEMIES LIGHT REACTION =====
function enemyLightFactor(ex, ey, lightRays) {
  const dx = ex - player.x, dy = ey - player.y;
  const dist = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx) - player.angle;
  if (Math.abs(angle) > FOV / 2) return 0;
  const idx = clamp(Math.floor((angle + FOV/2) / FOV * lightRays.length), 0, lightRays.length -1);
  const rayDist = lightRays[idx] || 0;
  return clamp((rayDist - dist) / 1.5, 0, 1);
}

function renderEnemies(lightRays) {
  for (const e of enemies) {
    const f = enemyLightFactor(e.x, e.y, lightRays);
    if (f <= 0) continue;
    const dx = e.x - player.x, dy = e.y - player.y;
    const dist = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx) - player.angle;
    const screenX = canvas.width/2 + Math.tan(angle) * (canvas.width/2)/Math.tan(FOV/2);
    const h = canvas.height / dist * e.size;
    ctx.fillStyle = f < 0.3 ? "rgba(0,0,0,0.8)" : `rgba(120,0,0,${f})`;
    ctx.fillRect(screenX - h*0.25, canvas.height/2 - h, h*0.5, h);
  }
}

// ===== UPDATE =====
function update() {
  let forward = 0, strafe = 0;
  if (keys["w"]) forward = player.speed;
  if (keys["s"]) forward = -player.speed;
  if (keys["a"]) strafe = -player.speed;
  if (keys["d"]) strafe = player.speed;

  // Forward/backward
  let nx = player.x + Math.cos(player.angle) * forward;
  let ny = player.y + Math.sin(player.angle) * forward;
  if (!isWall(nx, player.y)) player.x = nx;
  if (!isWall(player.x, ny)) player.y = ny;

  // Strafing
  nx = player.x + Math.cos(player.angle + Math.PI/2) * strafe;
  ny = player.y + Math.sin(player.angle + Math.PI/2) * strafe;
  if (!isWall(nx, player.y)) player.x = nx;
  if (!isWall(player.x, ny)) player.y = ny;

  flashlight.battery = Math.max(0, flashlight.battery - flashlight.drainRate);
}

// ===== RENDER =====
function render() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const halfH = canvas.height / 2;

  // --- floor & ceiling ---
  for (let y = 0; y < canvas.height; y++) {
    const d = Math.abs(y - halfH);
    const shade = clamp(60 - d * 0.2, 10, 60);
    ctx.fillStyle = `rgb(${shade},${shade*0.8},${shade*0.6})`;
    ctx.fillRect(0, y, canvas.width, 1);
  }

  // --- walls ---
  for (let i = 0; i < RAYS; i++) {
    const jitter = Math.sin(performance.now() * 0.004 + i * 0.3) * 0.002;
    const rayAngle = player.angle - FOV/2 + (i/RAYS)*FOV + jitter;
    let dist = castRay(rayAngle) * Math.cos(rayAngle - player.angle);
    dist = clamp(dist, 0.01, 50);
    const h = canvas.height / dist;
    const shade = clamp(200/dist, 30, 120);
    ctx.fillStyle = `rgb(${shade},${shade*0.7},${shade*0.4})`;
    ctx.fillRect(i*RES, halfH - h/2, RES, h);
  }

  // --- flashlight rays ---
  const lightRays = [];
  let acc = 0, samples = 0;
  for (let a = -0.15; a <= 0.15; a += 0.05) {
    acc += castRay(player.angle + a);
    samples++;
  }
  const avgDist = acc / samples;
  const target = clamp(avgDist / 6, 0.7, 1.15);
  smoothRadiusFactor += (target - smoothRadiusFactor) * 0.08;
  const pulse = healthPulse();
  const baseRadius = Math.min(canvas.width, canvas.height) * 0.45 * smoothRadiusFactor;

  // --- dynamic flashlight polygon per ray ---
ctx.save();
ctx.fillStyle = "rgba(0,0,0,0.9)";
ctx.fillRect(0,0,canvas.width,canvas.height);
ctx.globalCompositeOperation = "destination-out";

ctx.beginPath();
const centerX = canvas.width/2;
const centerY = canvas.height/2;

for (let i = 0; i < RAYS; i++) {
    const rayAngle = player.angle - FOV/2 + (i/RAYS)*FOV;
    let dist = castRay(rayAngle) * Math.cos(rayAngle - player.angle);
    dist = clamp(dist, 0.01, 50);

    const maxDist = 6 * flashlight.power;
    const rayFlicker = 0.85 + Math.random() * 0.3;

    // Each ray radius depends on distance -> further objects allow light to extend more
const rayRadius = baseRadius * clamp(dist / maxDist, 0, 1);

    const x = centerX + Math.cos(rayAngle) * rayRadius;
    const y = centerY + Math.sin(rayAngle) * rayRadius;

    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);

    lightRays.push(dist);
}

ctx.closePath();
ctx.fill();
ctx.restore();

  renderEnemies(lightRays);

  ctx.closePath(); ctx.fill(); ctx.restore();

  // --- soft penumbra ---
  ctx.save();
  ctx.globalCompositeOperation = "multiply";
  const pen = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, baseRadius*0.85,
    canvas.width/2, canvas.height/2, baseRadius*1.05
  );
  pen.addColorStop(0, "rgba(0,0,0,0)");
  pen.addColorStop(1, "rgba(0,0,0,0.45)");
  ctx.fillStyle = pen; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  // --- glow ---
  const g = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, 0,
    canvas.width/2, canvas.height/2, baseRadius
  );
  g.addColorStop(0, `rgba(255,240,220,${0.25*pulse})`);
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  // --- health bars ---
  ctx.fillStyle = "rgba(200,0,0,0.7)";
  const barWidth = 100, barHeight = 10;
  ctx.fillRect(20, 20, barWidth * (player.health / 100), barHeight);
  ctx.strokeStyle = "white";
  ctx.strokeRect(20, 20, barWidth, barHeight);
}
// ===== LOOP =====
function loop(){ update(); render(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
