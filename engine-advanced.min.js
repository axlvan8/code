//engine-advanced.min.js
////////////////////////////////////////
// BLOCK HIGHLIGHTING DURING EXECUTION
////////////////////////////////////////
let highlightBlock = null;
const canvas = document.getElementById('stage');
function highlight(blockElem) {
    if (highlightBlock) highlightBlock.style.boxShadow = "";
    if (blockElem) blockElem.style.boxShadow = "0 0 15px 5px yellow";
    highlightBlock = blockElem;
}
class Sprite {
    constructor(name) {
        this.name = name;
        this.x = 240;
        this.y = 180;
        this.dir = 0;
        this.size = 1;
        this.color = "#0077cc";
        this.costume = null;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.dir * Math.PI/180);
        ctx.fillStyle = this.color;
        ctx.fillRect(-15*this.size, -15*this.size, 30*this.size, 30*this.size);
        ctx.restore();
    }
}
let sprites = [new Sprite("Sprite1")];
function executeBlock(block, blockElem=null) {
    if (blockElem) highlight(blockElem);
    let t = block.type;
    let inp = block.inputs || [];
    switch(t){
        case "move":
            for (let s of sprites) {
                s.x += Math.cos(s.dir*Math.PI/180)*Number(inp[0]);
                s.y += Math.sin(s.dir*Math.PI/180)*Number(inp[0]);
            }
            break;
        case "turn":
            for (let s of sprites) s.dir += Number(inp[0]);
            break;
        case "repeat":
            for(let i=0;i<Number(inp[0]);i++)
                executeStack(block.substacks[0], blockElem.querySelector(".substack"));
            break;
        case "forever":
            setInterval(()=>executeStack(block.substacks[0], blockElem.querySelector(".substack")), 100);
            break;
        case "if":
            if(eval(inp[0]))
                executeStack(block.substacks[0], blockElem.querySelector(".substack"));
            break;
        case "ifelse":
            if(eval(inp[0]))
                executeStack(block.substacks[0], blockElem.querySelectorAll(".substack")[0]);
            else
                executeStack(block.substacks[1], blockElem.querySelectorAll(".substack")[1]);
            break;
    }
}

function executeStack(stack, elem=null) {
    for (let i=0;i<stack.length;i++){
        let blockElem = elem ? elem.children[i] : null;
        executeBlock(stack[i], blockElem);
    }
}

////////////////////////////////////////
// DRAG OUT TO DELETE
////////////////////////////////////////
const workspace = document.getElementById("workspace");
workspace.addEventListener("dragend", (e) => {
    if (!dragged) return;
    const rect = workspace.getBoundingClientRect();
    if (e.clientX > rect.right || e.clientY < rect.top) {
        dragged.remove();
    }
});

////////////////////////////////////////
// CUSTOM BLOCK EDITOR
////////////////////////////////////////
function createCustomBlock(name, inputCount=0) {
    const div = document.createElement("div");
    div.className = "block stack";
    div.dataset.type = name;
    let html = name;
    for (let i=0;i<inputCount;i++) html += ` <input type="text" class="num" value="">`;
    div.innerHTML = html;
    div.setAttribute("draggable", "true");
    document.getElementById("toolbox").appendChild(div);
}

// Example: createCustomBlock("say",1);

////////////////////////////////////////
// EVENTS SYSTEM
////////////////////////////////////////
let eventHandlers = { "greenFlag": [], "spriteClicked": [], "broadcast": {} };

function onGreenFlag(fn) { eventHandlers.greenFlag.push(fn); }
function onSpriteClicked(sprite, fn) {
    if (!eventHandlers.spriteClicked[sprite.name]) eventHandlers.spriteClicked[sprite.name] = [];
    eventHandlers.spriteClicked[sprite.name].push(fn);
}
function broadcast(msg) { 
    if (!eventHandlers.broadcast[msg]) return;
    for (let fn of eventHandlers.broadcast[msg]) fn();
}

document.getElementById("run").onclick = () => {
    for (let fn of eventHandlers.greenFlag) fn();
    runScript();
};

canvas.addEventListener("click", (e)=>{
    for (let s of sprites){
        let dx = e.offsetX - s.x;
        let dy = e.offsetY - s.y;
        if (dx*dx+dy*dy < 20*20){
            if (eventHandlers.spriteClicked[s.name]) 
                for (let fn of eventHandlers.spriteClicked[s.name]) fn();
        }
    }
});

////////////////////////////////////////
// MULTI-SPRITE / COSTUMES
////////////////////////////////////////
class Costume {
    constructor(name, color="#0077cc") {
        this.name = name;
        this.color = color;
    }
}

sprites[0].costumes = [new Costume("default","#0077cc")];
sprites[0].currentCostume = 0;

function addCostume(sprite, costume) {
    sprite.costumes.push(costume);
}

function switchCostume(sprite, idx) {
    if (idx < sprite.costumes.length) {
        sprite.currentCostume = idx;
        sprite.color = sprite.costumes[idx].color;
    }
}

////////////////////////////////////////
// SAVE / LOAD FULL PROJECT
////////////////////////////////////////
function saveProject() {
    let project = { sprites: [], script: serializeStack(document.getElementById("script-area")) };
    for (let s of sprites){
        project.sprites.push({
            name: s.name,
            x: s.x, y: s.y, dir: s.dir, size: s.size,
            costumes: s.costumes.map(c=>({name:c.name,color:c.color})),
            currentCostume: s.currentCostume
        });
    }
    localStorage.setItem("scratchProject", JSON.stringify(project));
    alert("Project saved!");
}

function loadProject() {
    const json = localStorage.getItem("scratchProject");
    if (!json) return;
    const data = JSON.parse(json);
    document.getElementById("script-area").innerHTML = "";
    rebuildStack(document.getElementById("script-area"), data.script);
    sprites = [];
    for (let sdata of data.sprites){
        let s = new Sprite(sdata.name);
        s.x = sdata.x; s.y = sdata.y; s.dir = sdata.dir; s.size = sdata.size;
        s.costumes = sdata.costumes.map(c=>new Costume(c.name,c.color));
        s.currentCostume = sdata.currentCostume;
        s.color = s.costumes[s.currentCostume].color;
        sprites.push(s);
    }
}

document.getElementById("save").onclick = saveProject;
loadProject();

////////////////////////////////////////
// JAVASCRIPT CODE GENERATOR
////////////////////////////////////////
function generateJS(stack) {
    let code = "";
    for (let b of stack){
        switch(b.type){
            case "move":
                code += `sprite.x += Math.cos(sprite.dir*Math.PI/180)*${b.inputs[0]};\n`;
                code += `sprite.y += Math.sin(sprite.dir*Math.PI/180)*${b.inputs[0]};\n`;
                break;
            case "turn":
                code += `sprite.dir += ${b.inputs[0]};\n`;
                break;
            case "repeat":
                code += `for(let i=0;i<${b.inputs[0]};i++){\n${generateJS(b.substacks[0])}}\n`;
                break;
            case "forever":
                code += `setInterval(()=>{\n${generateJS(b.substacks[0])}\n},100);\n`;
                break;
            case "if":
                code += `if(${b.inputs[0]}){\n${generateJS(b.substacks[0])}}\n`;
                break;
            case "ifelse":
                code += `if(${b.inputs[0]}){\n${generateJS(b.substacks[0])}} else {\n${generateJS(b.substacks[1])}}\n`;
                break;
            default:
                code += `// Custom block ${b.type}\n`;
        }
    }
    return code;
}

////////////////////////////////////////
// REFINE SNAP LOGIC (SIMPLE VERSION)
////////////////////////////////////////
function snapBlock(block, target){
    if (!target) return;
    const rectT = target.getBoundingClientRect();
    const rectB = block.getBoundingClientRect();
    block.style.position = "absolute";
    block.style.left = (rectT.left - rectB.width/2 + rectT.width/2) + "px";
    block.style.top = (rectT.top - rectB.height/2 + rectT.height/2) + "px";
}

// This completes the hybrid near-Scratch engine
console.log("Hybrid Scratch engine part 2 loaded.");
